{"./":{"url":"./","title":"Welcome","keywords":"","body":"helm3中文手册 Welcome 欢迎阅读 Helm 文档。 Helm是一个K8s的包管理工具, 更多详情信息请访问: CNCF Helm Project Journey report. Helm概述 Helm 帮助您管理 Kubernetes 应用——Helm 图表，即使是最复杂的 Kubernetes 应用程序，都可以帮助您定义，安装和升级。 图表 Chart 易于创建、发版、分享和发布，所以停止复制粘贴，开始使用 Helm 吧。 文档是如何组织的 Helm提供了大量的文档，大致的目录结构如下，读者可以根据自己的需求选择内容参考： Tutorials 手把手帮助你创建你的第一个helm Charts。对于一个helm新手而言，建议先阅读该文档。 How-to guides 是一些更加详细的手册，它们可以帮助你了解使用中的相关问题和关键步骤。相对Tutorial而言，guides中的内容会更加的深入。 Topic guides 从较高的层面讨论一些核心主题和概念并以相关背景知识进行辅助解释。 Community Guides 主要讨论Helm的社区相关主题，如果你想要为社区做贡献，相关的阅读是必不可少的。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap01/quickstart.html":{"url":"chap01/quickstart.html","title":"快速入门","keywords":"","body":"Helm引言 你是一个Helm新人吗？下面跟着我来一步步的学习Helm吧！ QuickStart 本节主要帮助你快速了解helm的使用。 前置条件 如果想要使用helm，需要首先满足如下条件： 有一个k8s集群 如果要开启安全性验证，需要提前设置相关的安全性策略 正确安装和配置helm 部署K8s集群或者能够访问一套K8s集群 需要提前部署好K8s集群，对于最新的稳定版helm而言，通常对应于K8s集群的版本是倒数第二个稳定版。 本地有一个已经提前配置到的 kubectl 工具. 关于Helm与K8s的版本兼容性问题，可以访问 Helm Version Support Policy 查询完整信息。 安装Helm 安装Helm本身非常简单，仅需要下载Helm客户端即可。 下载的方式可以使用一些包管理工具，例如homebrew或者Github官方发布产出地址： the official releases page 关于安装的更多细节，可以访问 install.md 文档进行了解。 初始化 Helm Chart 仓库 当Helm安装完成后，接下来就是需要配置charts仓库源了。一个常用的官方Helm稳定源的地址如下： helm repo add bitnami https://charts.bitnami.com/bitnami 接下来，你就能罗列出来当前你已经安装的charts: helm search repo bitnami # NAME CHART VERSION APP VERSION DESCRIPTION # bitnami/bitnami-common 0.0.9 0.0.9 DEPRECATED Chart with custom templates used in ... # bitnami/airflow 10.2.2 2.1.0 Apache Airflow is a platform to programmaticall... # bitnami/apache 8.5.7 2.4.48 Chart for Apache HTTP Server # bitnami/aspnet-core 1.3.7 3.1.16 ASP.NET Core is an open-source framework create... # bitnami/cassandra 7.6.2 3.11.10 Apache Cassandra is a free and open-source dist... # bitnami/cert-manager 0.1.4 1.4.0 Cert Manager is a Kubernetes add-on to automate... # bitnami/common 1.6.1 1.6.1 A Library Helm Chart for grouping common logic ... # bitnami/consul 9.2.14 1.10.0 Highly available and distributed service discov... # bitnami/contour 4.3.9 1.16.0 Contour Ingress controller for Kubernetes # bitnami/dataplatform-bp1 5.0.0 1.0.0 OCTO Data platform Kafka-Spark-Solr Helm Chart # ... and many more 安装一个示例charts 为了安装一个charts，你将会用到的是 helm install 命令。helm有多种方式查询和安装charts，其中最简单的方式使用官方的stable charts。 helm repo update # 确保拿到最新的charts helm install bitnami/mysql --generate-name # NAME: mysql-1625213307 # LAST DEPLOYED: Fri Jul 2 16:08:32 2021 # NAMESPACE: default # STATUS: deployed # REVISION: 1 # TEST SUITE: None # NOTES:... 在上面的例子中，我们使用了 bitnami/mysql charts，release的名称叫做 mysql-1625213307。 如果想要了解charts相关的概要信息，可以使用 helm show chart bitnami/mysql 命令。 想要获得更加详细的信息，则可以运行如下命令： helm show all bitnami/mysql 。 只要你install 一个 chart后，会自动创建一个新的release版本。所以同一个chart其实可以在一个集群中install多次。 而每个release版本都可以进行独立的管理和升级。 helm install 的命令非常强大，想要更加深入的了解，可以阅读 using_helm.md 文档。 release对象 通过如下命令可以查询当前所有的Helm的release对象： helm ls # NAME NAMESPACE REVISION UPDATED STATUS CHART APP VERSION # mysql-1625213307 default 1 2021-07-02 16:08:32.405932 +0800 CST deployed mysql-8.7.0 8.0.25 helm list 命令将会打印目前已经部署的一组release对象。 删除一个release对象 如果想要删除一个release对象，可以使用 helm uninstall 命令： helm uninstall mysql-1625213307 # Removed mysql-1625213307 这一操作将会从K8s中删除 mysql-1625213307 这个release对象中所有的关联资源以及release历史。 如果增加 --keep-history 参数，release历史将会被保存下来，仍然能够查询这一release对象之前的release历史。 helm status mysql-1625213307 # Status: UNINSTALLED ... 此时，即使你删除了该release对象，但由于Helm本身追踪记录了你的release历史，因此你仍然能够对集群对象历史进行审计，甚至必要的时候还可以通过 helm rollback 命令来恢复release对象。 帮助文档 为了了解更多的帮助文档, 可以使用 helm help 进行查询。 同时，对于每个子命令而言，也可以使用 -h 参数打印相关的帮助文档。 helm get -h By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap01/install.html":{"url":"chap01/install.html","title":"安装Helm","keywords":"","body":"Helm安装 本文主要讲解如何安装Helm CLI工具。 Helm可以通过源代码安装和二进制包安装等多种方式进行。 Helm项目官方提供了两种方式来安装Helm。 此外，Helm的社区来提供了通过不同包管理器的方式安装Helm。 接下来，我们将会依次介绍官方提供的方式和包管理器安装的方式。 Helm原生安装 二进制发布包安装 Helm的二进制包发布版本地址 release，它提供了各种操作系统下的二进制包。 这些二进制包可以直接进行手动下载和安装。 下载你想要的Helm版本的二进制包 解压二进制包 (tar -zxvf helm-v3.0.0-linux-amd64.tar.gz) 在解压目录下找到helm二进制文件，并把它移动到bin目录下即可。 (mv linux-amd64/helm /usr/local/bin/helm) 接下来，你就可以 添加repo源: helm help. 脚本安装 目前，helm有一个一键安装脚本可以自动化的下载并安装最新版本的helm。 你可以下载该脚本并手动执行。 $ curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 $ chmod 700 get_helm.sh $ ./get_helm.sh 同时，如果你想要一条命令搞定安装的任务，可以执行如下脚本： curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash 包管理器安装 Helm社区提供了各种操作系统下的包管理器的安装方式。 这些安装方式都不是Helm项目自身维护的，而是一些第三方伙伴开发和维护的。 Homebrew(macOS系统安装) brew install helm Chocolatey(Windows安装) Helm package 是由 Chocolatey 维护的。 choco install kubernetes-helm Apt(Debian/Ubuntu安装) Helm package for Apt curl https://baltocdn.com/helm/signing.asc | sudo apt-key add - sudo apt-get install apt-transport-https --yes echo \"deb https://baltocdn.com/helm/stable/debian/ all main\" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list sudo apt-get update sudo apt-get install helm Snap Snapcrafters 社区维护了 Helm package: sudo snap install helm --classic 开发版本安装 除了发布版本外，你还可以下载和安装Helm的开发版本。 金丝雀版本安装 金丝雀版本是由Helm的Master分支最新的代码产出的版本，它们没有经过完整的测试，可能会不太稳定，但是可以帮助用户了解Helm的最新功能。 Helm金丝雀版本产出存在 get.helm.sh。下面是一些常用平台的编译产出地址。 Linux AMD64 macOS AMD64 Experimental Windows AMD64 源码安装(Linux, macOS) 从源码构建helm的话需要稍微做一些工作，但是这是你想要测试最新版本helm的一个最好的方式。 首先，你需要搭建Go语言的开发环境。 $ git clone https://github.com/helm/helm.git $ cd helm $ make 此外，你还需要拉取相关的Go依赖库并且验证依赖是否完整。 当编译产出新的helm后，同样需要将他放到bin目录下。 总结 通常来说，安装helm二进制包是非常简单的。本文中也涵盖了大部分Helm安装的场景。 当你完成了Helm的安装后，下面你就可以用helm来进行Charts管理和操作了。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap01/using_helm.html":{"url":"chap01/using_helm.html","title":"helm命令行简介","keywords":"","body":"helm命令行 本文主要讲解使用helm命令行进行K8s包管理的一些基本操作。我们假定你已经完成了helm客户端的安装。 如果你只是想运行几个简单的命令，那么 快速入门 文档应该就已经能够满足你的需求了。 而本文讲解的命令相对来说更多且详解的更加清晰。 三个重要概念 在开始详解helm命令行操作之前，我们首先需要了解Helm的三个重要的概念：Chart，Repository，Release。 Chart 是Helm生态中的部署包。 它包含了为了在K8s中运行一个应用的所有资源信息。 Chart在K8s中的作用类似于 Homebrew包、APT DPKG包或者是YUM RPM文件一样。 Repository 是用于存储和共享Charts的一个平台，专门针对与K8s包的存储与共享。 Release 是一个Chart在一个K8s集群中运行的实体。在同一个K8s集群中，可以多次安装多一个 chart 。 每次安装一个 chart，都会创建一个新的 Release 。 例如对于一个MySQL Charts而言，如果你想要在你的K8s集群中创建两个数据库，那么你仅仅需要安装两次这个 chart 即可。 每次安装都会创建一个对应的 Release ，并且每次得到的 Release 名称都不相同。 当我们了解了这些概念后，我们可以这么理解Helm的作用： Helm可以把Charts安装到K8s集群中，并在对于每次安装都会创建一个新的release。 同时，如果你想要找到一些有用的charts时，你可以去chart Repository中进行查询。 'helm search': 查询Charts Helm提供了强大的搜索功能。 它可以用于搜索两种不同的源： helm search hub 用于搜索 the Helm Hub，它可以从各个不同的Helm源进行聚合搜索。 helm search repo 用于搜索你本地添加的helm源 (with helm repo add). 这种搜素方式是基于本地数据的，不需要公网连接即可完成。 你可以通过 helm search hub 命令搜索公开提供的charts: $ helm search hub wordpress URL CHART VERSION APP VERSION DESCRIPTION https://hub.helm.sh/charts/bitnami/wordpress 7.6.7 5.2.4 Web publishing platform for building blogs and ... https://hub.helm.sh/charts/presslabs/wordpress-... v0.6.3 v0.6.3 Presslabs WordPress Operator Helm Chart https://hub.helm.sh/charts/presslabs/wordpress-... v0.7.1 v0.7.1 A Helm chart for deploying a WordPress site on ... 上述的搜索结果就是在Helm Hub中所有到的所有workpress charts的记录。 如果不加任何搜索过滤词，那么 helm search hub 命令将会搜索出所有可用的charts。 使用 helm search repo 命令, 你可以用于查询你已经本地添加repo源的charts。 $ helm repo add brigade https://brigadecore.github.io/charts \"brigade\" has been added to your repositories $ helm search repo brigade NAME CHART VERSION APP VERSION DESCRIPTION brigade/brigade 1.3.2 v1.2.1 Brigade provides event-driven scripting of Kube... brigade/brigade-github-app 0.4.1 v0.2.1 The Brigade GitHub App, an advanced gateway for... brigade/brigade-github-oauth 0.2.0 v0.20.0 The legacy OAuth GitHub Gateway for Brigade brigade/brigade-k8s-gateway 0.1.0 A Helm chart for Kubernetes brigade/brigade-project 1.0.0 v1.0.0 Create a Brigade project brigade/kashti 0.4.0 v0.4.0 A Helm chart for Kubernetes Helm本身支持模糊搜索，所以你也可以仅仅输入关键词的一部分进行搜索： $ helm search repo kash NAME CHART VERSION APP VERSION DESCRIPTION brigade/kashti 0.4.0 v0.4.0 A Helm chart for Kubernetes 通过搜索，我们可以找到我们需要的charts，一旦我们找到了我们需要的charts，接下来，就可以使用 helm install 来进行安装了。 'helm install': 安装一个包 想要安装一个部署包，我们可以使用 helm install 命令。 对于一个最简单的命令而言，我们需要传入两个参数： release name chart name $ helm install happy-panda bitnami/wordpress NAME: happy-panda LAST DEPLOYED: Tue Jan 26 10:27:17 2021 NAMESPACE: default STATUS: deployed REVISION: 1 NOTES: ** Please be patient while the chart is being deployed ** Your WordPress site can be accessed through the following DNS name from within your cluster: happy-panda-wordpress.default.svc.cluster.local (port 80) To access your WordPress site from outside the cluster follow the steps below: 1. Get the WordPress URL by running these commands: NOTE: It may take a few minutes for the LoadBalancer IP to be available. Watch the status with: 'kubectl get svc --namespace default -w happy-panda-wordpress' export SERVICE_IP=$(kubectl get svc --namespace default happy-panda-wordpress --template \"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}\") echo \"WordPress URL: http://$SERVICE_IP/\" echo \"WordPress Admin URL: http://$SERVICE_IP/admin\" 2. Open a browser and access WordPress using the obtained URL. 3. Login with the following credentials below to see your blog: echo Username: user echo Password: $(kubectl get secret --namespace default happy-panda-wordpress -o jsonpath=\"{.data.wordpress-password}\" | base64 --decode) 现在，wordpress chart已经正常安装了，安装charts后，会对应的创建一个新的release对象。 这个release对象的名称是 happy-panda。 Ps：如果你懒得起名，也可以添加 --generate-name 让Helm自动为你的release对象分配名称。 在安装过程中，helm客户端将会打印一些帮助信息比如创建了哪些资源、当前release的状态以及是否有 一些额外的配置工作需要手动操作等。 Helm按照以下顺序安装资源： Namespace NetworkPolicy ResourceQuota LimitRange PodSecurityPolicy PodDisruptionBudget ServiceAccount Secret SecretList ConfigMap StorageClass PersistentVolume PersistentVolumeClaim CustomResourceDefinition ClusterRole ClusterRoleList ClusterRoleBinding ClusterRoleBindingList Role RoleList RoleBinding RoleBindingList Service DaemonSet Pod ReplicationController ReplicaSet Deployment HorizontalPodAutoscaler StatefulSet Job CronJob Ingress APIService helm本身并不会等待所有的资源对象成功创建后再退出。很多charts依赖的Docker镜像都很大，比如超过600M等。 拉取镜像到集群中本身也是一件相对耗时的事情。 为了查询release的状态或者查询配置相关信息，你可以使用 helm status 命令进行查询： $ helm status happy-panda NAME: happy-panda LAST DEPLOYED: Tue Jan 26 10:27:17 2021 NAMESPACE: default STATUS: deployed REVISION: 1 NOTES: ** Please be patient while the chart is being deployed ** Your WordPress site can be accessed through the following DNS name from within your cluster: happy-panda-wordpress.default.svc.cluster.local (port 80) To access your WordPress site from outside the cluster follow the steps below: 1. Get the WordPress URL by running these commands: NOTE: It may take a few minutes for the LoadBalancer IP to be available. Watch the status with: 'kubectl get svc --namespace default -w happy-panda-wordpress' export SERVICE_IP=$(kubectl get svc --namespace default happy-panda-wordpress --template \"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}\") echo \"WordPress URL: http://$SERVICE_IP/\" echo \"WordPress Admin URL: http://$SERVICE_IP/admin\" 2. Open a browser and access WordPress using the obtained URL. 3. Login with the following credentials below to see your blog: echo Username: user echo Password: $(kubectl get secret --namespace default happy-panda-wordpress -o jsonpath=\"{.data.wordpress-password}\" | base64 --decode) 上述内容都是该release的相关信息。 安装charts之前进行定制化改造 在前面的步骤中，我们仅仅使用了charts的默认配置进行安装。 然而在更多的时候，我们常常是需要对chart的配置进行一些定制化的修改的。 为了查询有哪些配置可以定制化修改，我们可以使用 helm show values 命令进行查询。 $ helm show values bitnami/wordpress ## Global Docker image parameters ## Please, note that this will override the image parameters, including dependencies, configured to use the global value ## Current available global Docker image parameters: imageRegistry and imagePullSecrets ## # global: # imageRegistry: myRegistryName # imagePullSecrets: # - myRegistryKeySecretName # storageClass: myStorageClass ## Bitnami WordPress image version ## ref: https://hub.docker.com/r/bitnami/wordpress/tags/ ## image: registry: docker.io repository: bitnami/wordpress tag: 5.6.0-debian-10-r35 [..] 根据上述说明，我们可以将要重写的配置写入一个yaml格式的配置文件中，并且在安装charts的时候传递这些文件。 $ echo '{mariadb.auth.database: user0db, mariadb.auth.username: user0}' > values.yaml $ helm install -f values.yaml bitnami/wordpress --generate-name 上述配置说明我们将会创建一个默认的MariaDB用户，名称是user0，同时创建一个新的Database为user0db，并授予这个用户访问该DB的权限。 而其余的信息，则统一使用默认配置。 其实，我们有如下两种方式在安装的过程中自定义配置数据： --values (or -f): 指定一个yaml配置文件进行配置重写，也可以同时指定多个配置文件，最右侧的配置优先级最高。 --set: 可以在命令行中传递重写的参数。 如果同时使用两个参数，--set的优先级会更高，重写到与--values中相同的配置项并与其他配置项合并。 使用--set重写的配置将会在ConfigMap中进行持久化。 同时，使用--set重写的配置还可以通过 helm get values 进行查询。 通过--set重写的配置在 helm upgrade 操作时，如果附带了 --reset-values 参数，则将会被清除。 --set 的使用方式与局限性 --set 参数可以接收0个或多个键值对参数。一个最简单的例子是： --set name=value 。 它等价于如下的yaml格式： name: value 多个键值对时，它们之间使用 , 进行分隔。例如： --set a=b,c=d 等价于： a: b c: d 此外，还有很多复杂的表达式，例如， --set outer.inner=value 等价于： outer: inner: value 列表可以用 { 和 } 进行包围，例如， --set name={a, b, c} 等价于： name: - a - b - c 自 Helm 2.5.0 版本后，还允许通过索引的方式访问列表，例如，--set servers[0].port=80等价于： servers: - port: 80 列表中的元素有多个Key时，设置方式 --set servers[0].port=80,servers[0].host=example 对应于： servers: - port: 80 host: example 有时，你需要在 --set 中传递一些特殊字符，此时则需要通过 \\ 进行转义，并用双引号包围，例如 --set name=value1\\,value2 对应于： name: \"value1,value2\" 类似的是，对于key中包含一些特殊符号时，可以使用相同的策略， --set nodeSelector.\"kubernetes\\.io/role\"=master 对应于： nodeSelector: kubernetes.io/role: master 对于多层嵌套的结构而言，--set表达式使用相对复杂。因此在设计 values.yaml 文件时，要考虑 --set 的使用方式，尽量避免多层嵌套。 相关内容可以了解：Values Files 更多的安装方式 helm install 命令可以用于安装各种各样的helm源，包括： A chart repository (之前的示例) 本地chart包 (helm install foo foo-0.1.1.tgz) 解压后的chart目录 (helm install foo path/to/foo) 完成的Chart包Url地址 (helm install foo https://example.com/charts/foo-1.2.3.tgz) 'helm upgrade' and 'helm rollback': Release的升级与回滚 当一个新版本的chart发布后，我们可以希望对我们的release进行升级。 此时，可以使用 helm upgrade 命令。 升级操作将基于你提供的信息和当前的release版本进行操作。 由于Kubernetes的charts可能会非常的复杂和庞大，因此，Helm会尝试进行增量升级。 也就说仅仅更新最近一次release变动的内容。 $ helm upgrade -f panda.yaml happy-panda stable/mariadb Fetched stable/mariadb-0.3.0.tgz to /Users/mattbutcher/Code/Go/src/helm.sh/helm/mariadb-0.3.0.tgz happy-panda has been upgraded. Happy Helming! Last Deployed: Wed Sep 28 12:47:54 2016 Namespace: default Status: DEPLOYED ... 在上面的例子中， happy-panda release 的升级过程中使用了相同的charts，但是传递了一个新的yaml配置文件： mariadb.auth.username: user1 你可以用 helm get values 去查询新的配置是否正常生效了。 $ helm get values happy-panda mariadb: auth: username: user1 helm get 命令在查询集群中的发布信息时非常有用。 如上所示，我们可以看到从 panda.yaml 配置文件中获取的相关配置。 现在，如果某个版本在发行过程中存在问题，则很容易进行回滚。 使用helm rollback [RELEASE] [REVISION]就可以回滚至之前的版本。 $ helm rollback happy-panda 1 上述的回滚操作将happy-panda回滚回了第一个版本。 release的版本号是一个增量增加的版本号。 每当进行一次安装、升级或者回滚等时，版本号都会+1。 一个新创建的release的版本号为1。 同时，我们还可以使用 helm history [RELEASE] 命令查询指定release的版本信息。 安装、升级、回滚中的一些有用的参数 在安装、升级、回滚等过程中，有一些有用的选项可以帮助我们定制操作的行为。 需要注意的是，下面列出的选项并不是全部的选项，更多的选项可以通过 helm --help 进行查询。 --wait: 等待所有的Pod状态变为Ready，PVC都绑定成功，Service完成IP分配。他将会阻塞等待直到超时或任务完成。 --timeout: 超时时间，默认为 5m0s --no-hooks: 跳过hook 'helm uninstall': 删除一个Release对象 当我们想要删除一个release对象时，可以执行如下命令： $ helm uninstall happy-panda 上述命令将会从集群中移除对应的release。 你可以使用 helm list 命令查询当前已经部署的所有release对象。 $ helm list NAME VERSION UPDATED STATUS CHART inky-cat 1 Wed Sep 28 12:59:46 2016 DEPLOYED alpine-0.1.0 从上面的输出可以看到，happy-panda release已经被正常删除了。 在Helm之前的版本中，当一个release对象被删除后，它的删除记录还会被保留。 但是在Helm3中，删除release对象时也会同步删除对应的发布记录。 如果你想要包含release的删除记录，可以在删除时使用： helm uninstall --keep-history 此时，可以使用 helm list --uninstalled 命令查询当前已经被删除的release对象。 helm list --all 将会查询所有release对象，包括使用--keep-history参数删除的release。 $ helm list --all NAME VERSION UPDATED STATUS CHART happy-panda 2 Wed Sep 28 12:47:54 2016 UNINSTALLED mariadb-0.3.0 inky-cat 1 Wed Sep 28 12:59:46 2016 DEPLOYED alpine-0.1.0 kindred-angelf 2 Tue Sep 27 16:16:10 2016 UNINSTALLED alpine-0.1.0 由于现在release记录默认会被删除，因此想要回滚一个已经被删除的release对象是无法完成的。 'helm repo': Repositories操作 Helm3中，已经不再默认添加相关的repo源了。 helm repo命令组提供了一组命令用于添加、查询和删除repo源。 helm repo list 可以查询当前的repo源: $ helm repo list NAME URL stable https://charts.helm.sh/stable mumoshu https://mumoshu.github.io/charts helm repo add 命令可以添加新的repo源: $ helm repo add dev https://example.com/dev-charts 由于chart repo会频繁的变更，为了保证你的源信息与最新新的同步，你可以经常运行 helm repo update 进行源信息同步。 helm repo remove 可以用于删除repo源。 创建你自己的charts Chart Development Guide 详细介绍了如何制作自己的charts。 此时，你可以使用 helm create 命令来快速体验一下: $ helm create deis-workflow Creating deis-workflow 此时就会有一个 ./deis-workflow 目录. 你可以编辑它并且创建自己的模板。 当你编辑你的charts过程中，可以使用 helm lint 验证格式是否合法。 当你的包内容制作完成后，可以运行 helm package 命令进行打包。 $ helm package deis-workflow deis-workflow-0.1.0.tgz 此时，制作完成的包可以通过 helm install 的方式进行安装: $ helm install deis-workflow ./deis-workflow-0.1.0.tgz ... 打包后的charts可以被上传到repo仓库中。更多细节可以参考 Helm Chart仓库 。 总结 本文主要讲解了 helm 客户端的基本使用方式，包含查询、安装、升级、卸载等。 同时，还讲解了其中一些有用的命令，例如 helm status, helm get 和 helm repo. 更多关于helm命令行相关的介绍可以使用内置的help命令进行查询： helm help By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap02/":{"url":"chap02/","title":"概述","keywords":"","body":"How-to 引导 在本章中，您会找到“我应该如何……？”的简短答案。 这些操作指南并没有很深入介绍主题，不过，这些指南将帮助您快速完成常见任务。 相关资源的深入介绍您可以在Topic Guides中找到该材料。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap02/charts_tips_and_tricks.html":{"url":"chap02/charts_tips_and_tricks.html","title":"Chart编写小技巧","keywords":"","body":"Chart编写小技巧 本文涵盖了一些Helm Charts开发人员一些需要了解的提示和技巧，学习本文有助于开发人员制作出高质量的charts。 了解你的模板功能 Helm 使用 Go templates 来模板化资源文件。 尽管Go本身内置了一些函数，但是我们还要添加一些其他的函数。 我们添加的所有函数位于：Sprig library. 我们还添加了两个模板函数: include and required. include 函数可以引入其他模板，并传递结果给其他模板函数。 例如，此模板代码段包含一个名为 \"mytpl\" 的模板，然后将内容小写化，最后用双引号引起来。 value: {{ include \"mytpl\" . | lower | quote }} required 函数可以声明某个字段在模板渲染中是必填的字段。 如果该字段为空，那么模板渲染将会失败并且返回用户对应的错误信息。 下面就是一个 required 函数的示例，它声明了 .Values.who 是必填的。 如果该字段为空，则会打印错误信息。 value: {{ required \"A valid .Values.who entry required!\" .Values.who }} 字符串需要引号包围，数字不需要 当你在处理字符串的时候，你最好将所有的结果最后增加 | quote 进行引号包围。 name: {{ .Values.MyName | quote }} 但是对于数字类型的变量而言，则不需要 | quote 进行引号包围，否则会导致解析错误。 port: {{ .Values.Port }} 不过如果它们的格式预期就是字符串格式，那么也应该增加 | quote 进行转化。 env: - name: HOST value: \"http://host\" - name: PORT value: \"1234\" 使用 include 函数 Go提供了一种使用内置模板指令将一个模板包含在另外一个模板中方法。 但是Go内置的函数不能用于Go模板管道。 为了能够支持模板包含和管道操作，Helm提供了一个 include 函数 {{ include \"toYaml\" $value | indent 2 }} 上述操作中，包含了一个名为 toYaml 的模板，传递给它一个 $value，并对它的输出执行了 indent函数操作。 由于YAML本身对缩进与空格非常的敏感，因此一种推荐的方式就是使用 include 引入代码段，再通过管道的方式处理缩进。 使用 'required' 函数 Go提供了一种设置模板选项来控制当Map中没有找到对应Key行为的方式。 其中，典型的设置方式就是：template.Options(\"missingkey=option\")。 其中， option 可以是 default, zero, or error。 当该 option 设置为error的时候，将会停止安装操作。 这种配置方式适用于Charts开发者希望用户必须在 values.yaml 中添加指定字段时使用。 required 函数能够使开发人员声明模板渲染的必填字段。 如果 values.yaml 中对应字段为空，则模板不会正常安装，并会返回开发人员提供的错误消息。 例如: {{ required \"A valid foo is required!\" .Values.foo }} 只有当 .Values.foo 字段定义后，才能正常工作。否则，它将会渲染失败。 使用 'tpl' 函数 tpl 函数允许开发人员将模板的执行值用于模板中。 这适用于传递模板字符串的值给chart或者给外部配置文件。 语法格式：{{ tpl TEMPLATE_STRING VALUES }} 例如： # values template: \"{{ .Values.name }}\" name: \"Tom\" # template {{ tpl .Values.template . }} # output Tom 渲染外部配置文件： # external configuration file conf/app.conf firstName={{ .Values.firstName }} lastName={{ .Values.lastName }} # values firstName: Peter lastName: Parker # template {{ tpl (.Files.Get \"conf/app.conf\") . }} # output firstName=Peter lastName=Parker 创建镜像拉取密钥 镜像拉取密钥是由镜像仓库、用户名和密码组成的。 你在部署你的应用的时候，可能需要用到这些信息，但是为了创建这些信息，你可能不得不多次进行base64编码等。 我们可以通过一个模板来接收Docker配置文件用于获得镜像拉取密钥，下面就是一个示例。 首先，假定授权信息是定义在 values.yaml 文件中： imageCredentials: registry: quay.io username: someone password: sillyness email: someone@host.com 此时，我们的模板格式可以如下： {{- define \"imagePullSecret\" }} {{- with .Values.imageCredentials }} {{- printf \"{\\\"auths\\\":{\\\"%s\\\":{\\\"username\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"email\\\":\\\"%s\\\",\\\"auth\\\":\\\"%s\\\"}}}\" .registry .username .password .email (printf \"%s:%s\" .username .password | b64enc) | b64enc }} {{- end }} {{- end }} 最后，我们可以在最终YAML的模板中引用我们自定义的模板来生成密钥信息。 apiVersion: v1 kind: Secret metadata: name: myregistrykey type: kubernetes.io/dockerconfigjson data: .dockerconfigjson: {{ template \"imagePullSecret\" . }} 自动化滚动升级 很多时候，ConfigMap或Secrets会作为配置文件注入到容器中，或者有其他外部依赖项更改需要重启Pod。 而很多应用的重启本身其实需要依赖于 helm upgrade 命令来完成。 但是，如果deployment 的spec配置没有发生变化时，则应用程序将继续使用旧配置运行，从而导致部署不生效。 其中，sha256sum 函数可以用于保证当其他文件更新时，deployment的annotation部分一定会发生变化。 kind: Deployment spec: template: metadata: annotations: checksum/config: {{ include (print $.Template.BasePath \"/configmap.yaml\") . | sha256sum }} [...] 如果你想要每次都触发相关部署，你可以使用一种类似的方式，即在annotation中使用一个随机字符串。 kind: Deployment spec: template: metadata: annotations: rollme: {{ randAlphaNum 5 | quote }} [...] 上述两种方式都可以保证你的应用在更新场景真正触发更新，而不会导致状态不一致的问题。 Ps：在Helm2中，我们使用 --recreate-pods 参数来保证每次更新，但是在Helm3中，我们移除了相关的参数，而是使用上述方式。 Helm删除时保留部分资源 有时，我们在执行 helm uninstall 时，可能希望Helm能够保留部分资源对象不要删除。 Charts开发任务可以编写相关的annotation来说明资源需要进行保留。 kind: Secret metadata: annotations: \"helm.sh/resource-policy\": keep [...] Ps: annotation的key需要用双引号包围起来。 annotation \"helm.sh/resource-policy\": keep 表示当进行helm操作，例如 helm uninstall, helm upgrade 以及 helm rollback 时，跳过删除资源的步骤。 但是，一旦设置了保留资源，这些资源将会被残留，不能再被helm进行管理。 这可能会导致在使用 helm install --replace 某个发布对象时，这个发布对象已经被删除了，但是资源还残留了下来。 使用 \"Partials\" 和 Template Includes 有时，你希望在你们chart中使用一些可复用的组件，它们可能时你的模板中的一部分。 通过提取可复用的组件，会让你的Charts文件看的更加清晰整洁。 在 templates/ 目录中，所有以下划线 (_) 开头的文件都不希望直接针对K8s创建，而是一些内部模板。 例如，一些帮助模板等常常会放在 _helpers.tpl 文件中。 包含很多依赖的复杂Charts 在 official charts repository 中，有很多charts其实是完整charts的一部分，主要用于被其他一些复杂应用来引用的。 最终，它们会组成一个大规模的应用。在这种场景中，一个Charts可能同时还包含很多的子Charts，每个子Charts都是完整项目的一部分。 当前，针对该场景的最佳实践是创建一个顶层的伞状结构，然后使用 charts/ 子目录来包含其他相关的charts组件。 YAML是JSON的超集 根据YAML规范，YAML是JSON的超集。这意味着任何有效的JSON结构都可以用YAML结构进行表示。 尽管有时模板开发人员可能会发现，使用类似于JSON的语法来表示数据结构比处理YAML这种空格敏感的方式更加有效。 但是作为最佳实践，模板最好还是要使用YAML格式语法。 生成随机数的使用要小心 Helm中有一些函数可以帮助你生成随机数、加密密钥等等。 这些功能很好用，但是在使用过程中，也需要加以注意。 因为在升级过程中，模板将会被重新执行，当模板产生的数据与上次不一致时，将会触发资源对象的更新部署。 使用同一条命令进行 安装/升级 release对象。 Helm提供了一种方式使得 安装/升级 release对象都使用同一条命令。 那就是使用 helm upgrade 命令并增加 --install 命令。 它的效果是当release已经存在时，执行升级操作；否则执行新增操作。 $ helm upgrade --install --values By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap02/chart_repository_sync_example.html":{"url":"chap02/chart_repository_sync_example.html","title":"Repo同步示例","keywords":"","body":"同步本地和远程Charts存储库 本文以 Google Cloud Storage (GCS) 块存储为例讲解如何进行 Chart Repo同步。 准备工作 安装 gsutil 工具。 helm二进制工具能够正常使用 创建本地Chart Repo目录 创建一个本地目录 然后将你的charts包放到该目录下。 例如： $ mkdir fantastic-charts $ mv alpine-0.1.0.tgz fantastic-charts/ 生成并更新index.yaml文件 传递工作目录和远程Repo地址作为参数使用helm来创建并更新 index.yaml 文件，示例如下： $ helm repo index fantastic-charts/ --url https://fantastic-charts.storage.googleapis.com 上述命令将会生成并修改一个index.yaml文件并将其放置在 fantastic-charts/ 目录下。 同步你的本地与远程repo 运行 scripts/sync-repo.sh 命令并传递本地目录名称和GCS块名称作为参数，来上传目录内容到GCS块中。 例如： $ pwd /Users/me/code/go/src/helm.sh/helm $ scripts/sync-repo.sh fantastic-charts/ fantastic-charts Getting ready to sync your local directory (fantastic-charts/) to a remote repository at gs://fantastic-charts Verifying Prerequisites.... Thumbs up! Looks like you have gsutil. Let's continue. Building synchronization state... Starting synchronization Would copy file://fantastic-charts/alpine-0.1.0.tgz to gs://fantastic-charts/alpine-0.1.0.tgz Would copy file://fantastic-charts/index.yaml to gs://fantastic-charts/index.yaml Are you sure you would like to continue with these changes?? [y/N]} y Building synchronization state... Starting synchronization Copying file://fantastic-charts/alpine-0.1.0.tgz [Content-Type=application/x-tar]... Uploading gs://fantastic-charts/alpine-0.1.0.tgz: 740 B/740 B Copying file://fantastic-charts/index.yaml [Content-Type=application/octet-stream]... Uploading gs://fantastic-charts/index.yaml: 347 B/347 B Congratulations your remote chart repository now matches the contents of fantastic-charts/ 更新你的Chart Repo 你可能想要保存本地Chart Repo的内容，同时想要使用 gsutil rsync 来将远程Chart Repo内容同步到本地目录。 例如: $ gsutil rsync -d -n gs://bucket-name local-dir/ # the -n flag does a dry run Building synchronization state... Starting synchronization Would copy gs://bucket-name/alpine-0.1.0.tgz to file://local-dir/alpine-0.1.0.tgz Would copy gs://bucket-name/index.yaml to file://local-dir/index.yaml $ gsutil rsync -d gs://bucket-name local-dir/ # performs the copy actions Building synchronization state... Starting synchronization Copying gs://bucket-name/alpine-0.1.0.tgz... Downloading file://local-dir/alpine-0.1.0.tgz: 740 B/740 B Copying gs://bucket-name/index.yaml... Downloading file://local-dir/index.yaml: 346 B/346 B 参考链接: gsutil rsync 文档 The Chart Repository Guide By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/charts.html":{"url":"chap03/charts.html","title":"Charts详解","keywords":"","body":"Charts详解 Helm使用的包的格式我们称之为 charts。 一个Charts中描述了一组相互关联的Kubernetes资源。 Charts既能部署复杂的应用，例如Memcached Pod，也能部署一些复杂的应用，例如一套包含了HTTP Server、数据据、缓存等等的完整项目。 Charts由一组特定的目录结构格式的文件组成的包，它们可以按照版本进行管理和部署。 如果你仅仅想要下载和查询Charts包而不想直接安装它们，那么你可以使用这个命令： helm pull chartrepo/chartname。 本文档主要用于讲解Charts的基本格式，并且讲解了构建Charts的基本指南。 Chart文件的结构 Charts是由一组文件组成了一个目录。其中，目录的名称与Charts的名称一致。 例如，一个WordPress应用的Chart通常会存储在一个 wordpress/ 目录中。 在这个目录中，Helm包期望的结构如下： wordpress/ Chart.yaml # YAML file 包含chart的基本信息。 LICENSE # OPTIONAL: chart的许可信息。 README.md # OPTIONAL: 用于介绍chart的说明文档。 values.yaml # Chart的默认配置文件。 values.schema.json # OPTIONAL: A JSON Schema指名values.yaml的数据格式。 charts/ # 一个目录，其中包含该Charts依赖的所有子Charts。 crds/ # 自定义资源定义文件 templates/ # 模板目录，与Value文件结合后，可以生成对应的合法的K8s资源文件。 templates/NOTES.txt # OPTIONAL: 简单的使用说明 Helm预留了 charts/, crds/, and templates/ 目录以及上面所列出的文件作为特殊文件。而其他名称的文件、目录将会被原样保留。 Chart.yaml 文件说明 Chart.yaml 是一个Chart中必备的文件，它包含如下字段： apiVersion: chart API 版本 (required) name: chart 名称 (required) version: chart 版本 (required) kubeVersion: K8s兼容版本 (optional) description: Chart文本描述 (optional) type: chart类型 (optional) keywords: - chart的关键词 (optional) home: 项目主页地址 (optional) sources: - 项目源代码 (optional) dependencies: # A list of the chart requirements (optional) - name: Chart名称 (nginx) version: Charts版本 (\"1.2.3\") repository: Chart地址或别名 (\"@repo-name\") condition: (optional) 一个Yaml路径，解析可以得到Bool值，从来判断是否存在依赖 (e.g. subchart1.enabled ) tags: # (optional) - Tag可以用于将charts分组并统一启用/禁用 enabled: (optional) 是否启动，决定是否加载 import-values: # (optional) - ImportValues保存原始值映射到父键中引用。 - 每条记录可以是一个字符串或者是一组子列表。 alias: (optional) Chart别名，当该Chart被多次引用时会有用 maintainers: # (optional) - name: 项目成员名称 (required for each maintainer) email: 项目成功email (optional for each maintainer) url: 项目成功个人地址 (optional for each maintainer) icon: SVG或PNG图像地址 (optional). appVersion: 应用版本 (optional). This needn't be SemVer. deprecated: 是否作废 (optional, boolean) annotations: example: 一组annotation key的名称 (optional). 其他的字段全部会被忽略 Charts的版本控制 每一个chart都必须包含一个版本号，同时版本号必须符合 SemVer2 标准。 在 repositories 中，通过 chart名称 + 版本号 来唯一标识对应的Chart包。 例如，一个 nginx charts的Version字段可以设置为 version: 1.2.3。 此时，Chart包的名称将会是： nginx-1.2.3.tgz SemVer2还支持一些复杂的版本设置，例如： version: 1.2.3-alpha.1+ef365。但是一定需要符合SemVer标准。 Chart.yaml 文件中的 version 字段在很多Helm工具中都会用到，例如CLI工具。 当创建一个包时， helm package 命令将会从 Chart.yaml 文件中找出对应的版本信息并作为部署包中的Token信息。 Helm要求Chart包名称中的版本号必须与 Chart.yaml 中的Version信息一致。 apiVersion 字段 对于必须Helm 3以上版本安装的Chart而言，apiVersion 字段应该设置为 v2。 而对于同时支持早期Helm版本的Charts而言，apiVersion 字段应该设置为 v1。 从v1版本迁移到v2版本: v2版本中增加了一个 dependencies 字段用于定义Charts之间的依赖关系，而在v1版本中，则是使用了一个单独的 requirements.yaml 文件来表示依赖。Chart Dependencies). type字段区分了应用charts与library charts。Chart Types). appVersion 字段 appVersion 字段与 version 字段无关，它是一个用于指定应用版本的方式。 例如，drupal Chart可能有一个 appVersion: 8.2.1 用于表明Charts中Drupal的版本默认为 8.2.1。 这个字段其实是一个提示字段，对应Chart Version计算等而言不起任何作用。 kubeVersion 字段 kubeVersion 可以用于定义当前charts支持的Kubernetes版本。 Helm在安装charts服务时将会验证kubernetes的版本是否兼容，如果kubernetes版本不兼容，则会安装失败。 版本约束表达式空格分隔的多个且条件，例如： >= 1.13.0 如果想要表达 或 的含义，需要使用 || 分隔符。 >= 1.13.0 = 1.14.1 在上面的示例中，1.14.0 版本被排除了，这种方式适用于当某个版本中确定存在某个特定的bug时，可以阻止Chart错误运行。 在版本限制表达式中，除了支持 = != > >= 这些操作符外，还支持如下这些简单符号： 对于闭区间范围而言， 1.1 - 2.3.4 等价于 >= 1.1 . 通配符 x, X and *。 例如 1.2.x 等价于 >= 1.2.0 . 小区间范围, 例如 ~1.2.3 等价于 >= 1.2.3 . 大区间范围, 例如 ^1.2.3 等价于 >= 1.2.3 . 关于更多的版本约束表达式使用方式，可以参考：Masterminds/semver. 废弃 Charts 在Chart Repository中管理charts时，有时我们需要废弃一个chart。这时，我们可以用到Chart.yaml文件中的deprecated字段。 如果一个chart的 latest 版本的chart被标记为废弃，那么会将这个Chart都标记为废弃。 当然，后续你还能用相关的Chart名发布新的chart并取消废弃标记。 关于废弃chart的工作流可以参考：kubernetes/charts。 主要包含如下几步： 更新chart的 Chart.yaml 表示该chart作废。 在 Chart Repository 中发布新的chart版本。 从源代码库删除该chart代码。 Chart类型 type 字段定义了chart的类型。 其中，包含两种类型的Type，分别是：application 和 library。 默认的Type类型为application，它是标准类型的Chart，可以用于直接操作。 而 library chart 则是一种用于提供一些工具和函数来构建其他Chart的Chart。 library chart与application chart最本质的区别是它不能直接安装，通常也不会包含任何的资源对象。 Ps：如果把一个 application chart的type字段改为 library，那么它就可以作为一个library chart。 此时，该chart中的所有工具和函数可以被使用，但是所有的资源对象都会失效。 LICENSE, README and NOTES 在一个Charts中，同样会包含一些文件用于描述Chart的安装、配置、使用和许可信息。 LICENSE是一个文本文件，包含这个Chart的license。 charts可以包含一个许可证，它可能会在模块中存在替换逻辑，因此可能不能仅仅是一个配置。 如果有必要的话，可以对Chart中的不同应用创建不同的LICENSE。 Chart中的README文档通常要求为 Markdown 格式（README.md），并且包含如下内容： 对Chart提供的应用和服务的功能描述。 该图片使用前的准备工作和相关依赖。 values.yaml 文件中的参数可选项与默认值 其他与Chart安装与配置相关的任何信息 当一些用户界面显示该Chart详情时，首先看到的将会是这个chart中README.md文件的内容。 在chart中，同样还可以包含一个 templates/NOTES.txt 文件用于在安装完成或查询release状态时能够打印到标准输出中。 该文件可以用于打印相关的使用方式、安装后的下一步、以及其他Chart相关的任何信息。 例如，可以提供用于连接到数据库或访问Web UI的指令。 由于在运行“ helm install”或“ helm status”时此文件被打印到STDOUT，因此建议保持内容简短并指向README以获取更多详细信息。 Chart 依赖 在Helm中，一个Chart可能会依赖一系列其他的Chart。 这些依赖关系将会在 Chart.yaml 文件中的 dependencies 字段中进行动态解析 或者是 通过 charts/ 目录进行手工管理。 使用 dependencies 字段管理依赖 当前Chart依赖的其他Charts可以定义为 dependencies 字段中对应的一组元素。 dependencies: - name: apache version: 1.2.3 repository: https://example.com/charts - name: mysql version: 3.2.1 repository: https://another.example.com/charts name 字段表示依赖chart的名称 version 字段表示依赖chart的版本 repository 字段是Chart Repo完整url。注意，你必须手动使用 helm repo add 命令将其添加到本地repo源中。 此外，你有可能会使用repo的名称来代替它的完整url地址。 $ helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com dependencies: - name: awesomeness version: 1.0.0 repository: \"@fantastic-charts\" 当你完成了依赖关系的定义后，你可以使用 helm dependency update 命令将它们都下载到你的 charts/ 目录中。 $ helm dep up foochart Hang tight while we grab the latest from your chart repositories... ...Successfully got an update from the \"local\" chart repository ...Successfully got an update from the \"stable\" chart repository ...Successfully got an update from the \"example\" chart repository ...Successfully got an update from the \"another\" chart repository Update Complete. Happy Helming! Saving 2 charts Downloading apache from repo https://example.com/charts Downloading mysql from repo https://another.example.com/charts 通过执行上面的命令，我们应该可以看到在charts目录中存在如下文件： charts/ apache-1.2.3.tgz mysql-3.2.1.tgz dependencies中的alias字段 除了上面描述的字段外，在每个依赖的chart中，可能都会包含一个可选字段 alias。 为依赖的charts添加alias后，在拉取依赖后，将会以别名的方式进行保存。 例如，我们可以通过alias的方式来访问对应的Charts： # parentchart/Chart.yaml dependencies: - name: subchart repository: http://localhost:10191 version: 0.1.0 alias: new-subchart-1 - name: subchart repository: http://localhost:10191 version: 0.1.0 alias: new-subchart-2 - name: subchart repository: http://localhost:10191 version: 0.1.0 在上面的示例中，我们可以看到在 parentchart 中存在3个依赖。 subchart new-subchart-1 new-subchart-2 手动获取依赖的方式是可以拉取原始Charts包，然后拷贝复制为不同的名称后保存到 charts/ 目录下。 dependencies 中的 Tags 和 Condition 字段 除了上面提及的字段外，每个依赖chart可能还会包含可选字段 tags 和 condition。 所有的依赖charts默认情况下都会被加载。 但是如果增加了 tags 或 condition 字段后，它们将进行判断对应依赖charts是否需要被加载。 Condition： Condition字段可以由一个或多个YAML PATY的字符串（用逗号分隔）组成。如果该YAML PATH对应的内容在父Values文件中存在且可以被解析成为一个布尔值，将根据布尔值的结果来判断是否启用该依赖。 如果对应的YAML PATH解析不存在，则该Contidion等价于没有设置，不会生效。 Tags: Tag字段是Chart YAML中一组label组成的列表。 在顶层的父Value文件中，可以通过指定Tag对应的布尔值来批量启用/禁用相关的依赖charts。 # parentchart/Chart.yaml dependencies: - name: subchart1 repository: http://localhost:10191 version: 0.1.0 condition: subchart1.enabled, global.subchart1.enabled tags: - front-end - subchart1 - name: subchart2 repository: http://localhost:10191 version: 0.1.0 condition: subchart2.enabled,global.subchart2.enabled tags: - back-end - subchart2 # parentchart/values.yaml subchart1: enabled: true tags: front-end: false back-end: true 在上面的例子中，subchart1有一个tag front-end。 由于在 value.yaml文件中，front-end是被禁用的，但是对于 subchart1.enabled 而言，又被设置为了启用。 因此对于 subchart1 而言，最终还是被启用了。 由于 subchart2 打了 back-end Tag，同时该Tag被设置为了 true，因此，subchart2 将会被启用。 另外，需要注意的是尽量 subchart2 设置了一个Condition，但是由于没有传入对应的Values，相当于该condition不会生效。 在cli中使用Tags 和 Condition 使用 --set 参数可以用于设置或改变 Tag 和 Condition 的值。 helm install --set tags.front-end=true --set subchart2.enabled=false Tags 和 Condition 解析 Conditions的优先级高于Tags。存在多个Conditions时，以匹配的第一个Conditions为准，后续的Conditions会被忽略。 Tag计算的方式是 如果Charts中的任意Tag为true，则启用该Charts。 Tag和Condition的设置必须在父Chart的Value文件中。 tags: 必须位于顶层key。目前不支持全局和嵌套 tags。 通过依赖项导入子值 在某些情况下，希望允许子charts的值传播到父charts并作为通用默认值共享。 使用 exports 格式的另一个好处是，它将使将来的工具能够自动补全用户设置的值。 在charts文件中的 dependencies 列表中，import-values字段中包含的数据可以被导入到父charts中。 import-values字段中的每个数据项都是从 子charts的yaml文件 中的 exports 字段导出的。 如果想要导入 exports 中没有包含的key，那么需要使用 child-parent 的方式。 下面，我们将依次对上述两种场景给以示例进行说明。 使用export的方式导入数据 如果一个子chart的 values.yaml 文件在根目录中包含一个 exports 字段，那么它就可以直接通过在父chart中进行import，从而导入到父Charts中。 如下所示： # parent's Chart.yaml file dependencies: - name: subchart repository: http://localhost:10191 version: 0.1.0 import-values: - data # child's values.yaml file exports: data: myint: 99 由于我们在import-values中指定了具体的key为 data，因此，Helm将会从子chart中找出对应的 exports 字段，并将其中的 data key的内容导入到父chart中。 最终，父Chart的Value中将会包含我们子charts中导出的指定字段。 # parent's values myint: 99 Ps：需要注意的是，导入数据后，之前的数据的key data 并没有包含在父chart的value中。 如果你想要把数据的key同时保存到父chart的value中，那么就需要了解下面的 'child-parent' 方式了。 使用child-parent方式导入数据 如果想要获取在子chart中没有显式进行 exports 的字段，那么，你就需要指定导入的值的原始键（子chart中）以及导入到父Chart中的目标位置。 在下面的例子中，import-values告诉Helm需要找出 child 中指定的所有的value值并他们拷贝到 parent 中指定的父value的指定key下。 # parent's Chart.yaml file dependencies: - name: subchart1 repository: http://localhost:10191 version: 0.1.0 ... import-values: - child: default.data parent: myimports 在上述例子中，在subchart1子Chart中找到的 default.data 的数据将会到导出到父Chart指定的 myimports的key中，如下所示： # parent's values.yaml file myimports: myint: 0 mybool: false mystring: \"helm rocks!\" # subchart1's values.yaml file default: data: myint: 999 mybool: true The parent chart's resulting values would be: # parent's final values myimports: myint: 999 mybool: true mystring: \"helm rocks!\" 最终，父chart中包含的 myint 和 mybool 字段将会被从 subchart1 子chart中导入的数据进行覆盖。 通过 charts/ 目录手工管理Chart依赖项 如果需要对依赖项进行更加复杂的管理，那么也可以手动把对应的依赖Charts拷贝至 charts/ 目录中来明确指明相关依赖。 依赖既可以是一个压缩包文件（foo-1.2.3.tgz），也可以是一个解压后的目录。 但是目录/文件名称不能以 _ 或者 . 开头，否则这些文件将会被忽略。 例如，对于一个 WordPress Chart 而言，它会依赖一个 Apache 的Chart。 因此，我们可以将 Apache Chart放入到 WordPress的Chart中的 charts/ 目录下即可。 wordpress: Chart.yaml # ... charts/ apache/ Chart.yaml # ... mysql/ Chart.yaml # ... 上面的示例表示了对于一个WordPress的Chart，它依赖了一个Apache和一个MySQL的Chart。 Ps： 要将依赖项拉取至charts/目录，可以使用helm pull命令。 依赖项工作方式说明 上面的示例中说明了如何指定Chart之间的依赖关系，但是具体在 helm install 或 helm upgrade 操作时，这些依赖项是如何工作的呢？ 假设一个名为A的Chart创建了以下Kubernetes对象： namespace \"A-Namespace\" statefulset \"A-StatefulSet\" service \"A-Service\" 另外，A的一个依赖项B创建了如下Kubernetes对象： namespace \"B-Namespace\" replicaset \"B-ReplicaSet\" service \"B-Service\" 在执行Chart A的安装和升级操作后会得到一个release对象，该release对象将会以如下顺序更新、创建上述所有的kubernetes对象： A-Namespace B-Namespace A-Service B-Service B-ReplicaSet A-StatefulSet 这是由于在安装、升级Chart的时候，Chart中的所有的Kubernetes对象及其所有的依赖项处理方式如下： 聚合成一个集合。 按照对象类型进行排序。 按照排序后的顺序依次进行创建。 因此，最终Chart及其依赖Charts的所有的资源对象都会由一个release进行创建。 Kubernetes类型的安装顺序由kind_sorter.go中的枚举InstallOrder给出（请参阅Helm源文件）。 模板和值 Helm的Chart模板是由 Go template language 为基础编写的。 另外还在Sprig library添加了50多个其他的模板函数。 同时还有一小部分专用函数 所有的模板文件都存储在Chart包的 templates/ 目录下。 在Helm渲染整个chart的时候，它将通过模板引擎处理该目录中的每个文件。 模板中的Values可以通过两种方式来提供： Chart开发人员在Chart包内部提供一个 values.yaml的文件，这一文件可以用于包含相关Charts的默认值。 Chart用户可以通过一个YAML文件来指定相关的值，或者也可以通过在 helm install 的命令行中传递该值。 当用户提供了自定义的值后，这些用户传递的自定义的值将会覆盖默认的 values.yaml 文件。 模板文件 模板文件需要遵循用于编写Go模板的标准约定（参见the text/template Go package documentation ）。 示例如下： apiVersion: v1 kind: ReplicationController metadata: name: deis-database namespace: deis labels: app.kubernetes.io/managed-by: deis spec: replicas: 1 selector: app.kubernetes.io/name: deis-database template: metadata: labels: app.kubernetes.io/name: deis-database spec: serviceAccount: deis-database containers: - name: deis-database image: {{ .Values.imageRegistry }}/postgres:{{ .Values.dockerTag }} imagePullPolicy: {{ .Values.pullPolicy }} ports: - containerPort: 5432 env: - name: DATABASE_STORAGE value: {{ default \"minio\" .Values.storage }} 上面的示例是基于 https://github.com/deis/charts 项目。 它是用于描述一个K8s的ReplicationController对象。 它可以使用如下四个模板值进行渲染（通常会在values.yaml文件中定义）： imageRegistry: Docker镜像仓库. dockerTag: 镜像Tag. pullPolicy: 镜像拉取策略. storage: 数据存储后端, 默认值为 \"minio\" 所有的这些值都是由模板开发人员指定的，Helm并不明确进行相关参数名称等的规定。 如果想要查询更多的Charts的示例，可以查询：Kubernetes Charts project。 预定义文件 在模板文件中，可以通过 .Values 的方式来访问 values.yaml 或 --set 设置的 value的值。 除此之外，还有一些预定义变量也可以使得数据可以在模板中使用。 以下是所有的预定义变量，可用于每个模板，并且不能被覆盖。同时，与其他所有值一样，名称区分大小写。 Release.Name: Release名称。 Release.Namespace: Release所属的Namespace。 Release.Service: 发布Release的服务。 Release.IsUpgrade: 对于升级、回滚操作而言，该变量值为true。 Release.IsInstall: 对于安装操作而言，该变量值为true。 Chart: Chart.yaml的文件内容，因此，Chart Version可以表示为 Chart.Version，Chart 维护者可以表示为 Chart.Maintainers。 Files: Chart中一个字典类型的对象，包含所有非特殊的文件。它无法让你访问模板文件，但是可以其他访问其他文件（除非使用.helmignore进行过滤）。 你可以使用 {{ index .Files \"file.name\" }} 或者 {{ .Files.Get name }} 函数的方式来访问文件。 此外，你还可以使用 {{ .Files.GetBytes }} 的方式读取文件中的内容作为 []byte 格式。 Capabilities: 一个字典类型的对象，包含K8s相关的版本信息 ({{ .Capabilities.KubeVersion }} 以及支持的K8s API 版本 ({{ .Capabilities.APIVersions.Has \"batch/v1\" }}) PS：任何未知的 Chart.yaml 字段信息将会被丢弃，他们无法在 Chart 对象中进行访问。因此，Chart.yaml 不能用于传递一些结构化数据到模板中。 如果存在相关的需求，可以使用Value文件。 Value文件 以上述模板为例，一个包含必要字段的示例的 values.yaml 文件如下： imageRegistry: \"quay.io/deis\" dockerTag: \"latest\" pullPolicy: \"Always\" storage: \"s3\" 上面的Yaml文件是YAML格式的。 一个Chart中可能会包含一个名为 values.yaml 的文件用于提供相关变量的默认值。 而在Helm安装Chart的过程中，还允许用户通过提供一个新的YAML文件来覆盖相关的默认值。 $ helm install --generate-name --values=myvals.yaml wordpress 当install过程中传递了相关变量时，这些变量值将会与 value.yaml 文件中的默认值进行合并。 例如，假设命令行中传入的 myvals.yaml 文件的内容如下： storage: \"gcs\" 此时，与 values.yaml 的内容进行合并后，得到的结果将会如下： imageRegistry: \"quay.io/deis\" dockerTag: \"latest\" pullPolicy: \"Always\" storage: \"gcs\" 如上所示，只有 storage 字段被进行了覆盖。 注意： Chart内的默认值文件名称必须是 value.yaml。但是在命令行中指定的文件名称可以自定义。 注意： 如果在helm install 和 helm upgrade 中使用 --set 时，这些参数实际是会在客户端转化为YAML格式进行传递的。 注意： 如果在value文件中有一些项是必填的，那么可以在模板中使用 required 进行声明，详见 'required' function values中传入的所有数据都可以在模板中通过 .Values 的方式进行读取： apiVersion: v1 kind: ReplicationController metadata: name: deis-database namespace: deis labels: app.kubernetes.io/managed-by: deis spec: replicas: 1 selector: app.kubernetes.io/name: deis-database template: metadata: labels: app.kubernetes.io/name: deis-database spec: serviceAccount: deis-database containers: - name: deis-database image: {{ .Values.imageRegistry }}/postgres:{{ .Values.dockerTag }} imagePullPolicy: {{ .Values.pullPolicy }} ports: - containerPort: 5432 env: - name: DATABASE_STORAGE value: {{ default \"minio\" .Values.storage }} Scope、Dependencies、Values values文件可以在Chart的顶层目录中声明相关的value，同样也可以在 charts/ 目录中包含的Charts中声明对应的value。 换句话说，value文件可以为当前的chart以及它所有依赖的charts提供对应的配置值。 例如，上面的演示WordPress charts同时具有mysql和apache作为依赖项。values文件可以为所有这些组件提供值： title: \"My WordPress Site\" # Sent to the WordPress template mysql: max_connections: 100 # Sent to MySQL password: \"secret\" apache: port: 8080 # Passed to Apache 父目录的charts可以访问其定义的所有变量，因此，WordPress charts可以访问MySQL密码.Values.mysql.password。 但是子目录的charts无法访问父charts中的内容，因此MySQL将无法访问该title属性，同时，它也无法访问 apache.port。 Values文件中是包含命令空间的，同时在引用value的时候还会剪切到命名空间。 以WordPress chart为例，它可以通过.Values.mysql.password访问MySQL的password的字段。 但是对于MySQL chart而言，引用value中的配置时，则不需要带有mysql前缀了，可以直接简化为 .Values.password。 全局Values 从2.0.0-Alpha.2开始，Helm支持了全局变量。考虑上一个示例的修改后的版本： title: \"My WordPress Site\" # Sent to the WordPress template global: app: MyWordPress mysql: max_connections: 100 # Sent to MySQL password: \"secret\" apache: port: 8080 # Passed to Apache 在上面的实例中，包含了一个 global 块，包含 app: MyWordPress。 这个值可以被所有的charts通过 .Values.global.app 获取对应的值。 例如，mysql的模板中，可以使用如下方式进行访问 {{ .Values.global.app}}，apache chart 也是一样的。 实际上，上面的value文件相当于重新生成如下内容： title: \"My WordPress Site\" # Sent to the WordPress template global: app: MyWordPress mysql: global: app: MyWordPress max_connections: 100 # Sent to MySQL password: \"secret\" apache: global: app: MyWordPress port: 8080 # Passed to Apache 这提供了一种与所有子charts共享一个顶级变量的方法，这对于诸如设置metadata标签之类的属性很有用。 如果子图声明了全局变量，则该全局变量将向下传递到子图的子图，而不向上传递到父图。即子charts无法影响父charts的值。 此外，父charts的全局变量优先于子图中的全局变量，即同时存在父charts和子charts拥有相同的全局变量值，会以父charts的全局变量为准。 Schema文件 有时，Chart开发人员希望想要定义他们的value文件的结构格式。 此时，就会用到一个values.schema.json的schedule文件。 该schema称之为JSON Schema。 类似如下格式： { \"$schema\": \"https://json-schema.org/draft-07/schema#\", \"properties\": { \"image\": { \"description\": \"Container Image\", \"properties\": { \"repo\": { \"type\": \"string\" }, \"tag\": { \"type\": \"string\" } }, \"type\": \"object\" }, \"name\": { \"description\": \"Service name\", \"type\": \"string\" }, \"port\": { \"description\": \"Port\", \"minimum\": 0, \"type\": \"integer\" }, \"protocol\": { \"type\": \"string\" } }, \"required\": [ \"protocol\", \"port\" ], \"title\": \"Values\", \"type\": \"object\" } 上述schema文件将会在执行如下命令时进行value值的合法性验证： helm install helm upgrade helm lint helm template 以一个 values.yaml 文件为例，该文件就是满足上述schema校验的。 name: frontend protocol: https port: 443 需要注意的是，该schema的生效范围是 .Values 对象，而不仅仅是 values.yaml 文件。 也就是说，即使 yaml 文件是满足 schema 校验的，但是如果 --set 参数传入的值不满足该schema校验，该请求也会被拦截。 name: frontend protocol: https helm install --set port=443 另外，最终的 .Values 对象是需要经过所有的子Charts的schema检查的。 这也就意味着父Charts也不能规避对子Charts的约束。 换句话说，如果子Chart的 value.yaml 文件没有满足本身的约束，那么在父Chart中必须满足相关的限制后才能正常工作。 更多参考 在你编写模板文件、Value文件以及Schema文件时，如下一些官方文档可能会对你有一些帮助。 Go templates Extra template functions The YAML format JSON Schema 自定义资源对象 (CRDs) K8s提供了一种机制用于声明一些新的kubernetes对象类型。 使用自定义资源对象(CRDs)，Kubernetes开发成员可以自定义各种各样的资源类型。 在Helm3中，CRDs是被当做一种特殊的资源对象来处理的。 它们会在Chart中其他资源对象安装之前首先进行安装，同时收到一些相关的限制。 CRD YAML 文件应该位于Chart包中的 crds/ 目录下。 多个CRDs的定义可能会存在于同一个文件中。 Helm会尝试加载 crds/ 目录下的所有文件并在K8s中进行创建。 CRD 文件不能是模板文件，必须是直接可以使用的YAML文档。 当Helm安装一个新的Chart时，它第一步会首先创建所有的CRD，当CRD全部创建完成且API Server侧可用后，然后才会通过模板引擎渲染其他的Chart模板等，并发送给Kubernetes。 由于遵循着这一严格的顺序，因此在CRD相关的信息可以在Helm模板中的 .Capabilities 对象中获取相关信息，而在Helm模板中也可以创建一个自定义CRD类型的实例。 例如，如果你的Chart中 crds/ 目录下存在一个 CronTab CRD，从而，你可以在 templates/ 目录下创建 CronTab 类型的实例： crontabs/ Chart.yaml crds/ crontab.yaml templates/ mycrontab.yaml crontab.yaml 必须是一个CRD的标准YAML文件，而不是模板文件： kind: CustomResourceDefinition metadata: name: crontabs.stable.example.com spec: group: stable.example.com versions: - name: v1 served: true storage: true scope: Namespaced names: plural: crontabs singular: crontab kind: CronTab 接下来的模板文件 mycrontab.yaml 中，就可以创建 CronTab 类型的实例了： apiVersion: stable.example.com kind: CronTab metadata: name: {{ .Values.name }} spec: # ... Helm会保证先创建 CronTab CRD对象，等待API Server中对应的CRD可用后，再去处理 templates/ 下的相关模板。 CRDs的相关限制 与K8s中其他大部分的对象不同，CRDs是全局性资源。因此，Helm在创建CRDs资源的时候非常谨慎，CRDs需要满足如下一系列限制： CRDs不会重复安装，如果Helm发现 crds/ 目录下的CRDs已经在K8s中安装（无论版本是否一致）了，那么Helm都不会重新安装或者升级。 CRDs不会进行升级和回滚操作，仅仅会执行安装操作。 CRDs不会被删除，由于删除CRDs会导致所有Namespace下对应该CRDs类型的资源都被删除，因此，Helm不会去删除CRDs。 总之，如果想要升级、修改、删除CRDs时，需要手工进行处理。 Chart Repositories Chart Repositories本质上就是一个存放打包后的Charts的一个HTTP服务器。 helm 可以用于管理本地的Charts目录，如果想要与他人共享Charts时，就会首先想到Chart Repositories了。 任何一个HTTP服务器，只要能够存放YAML文件和Tar包，同时能够通过GET请求下载相关资源时，都可以作为一个repository Server。 Helm团队本身测试了一些Server，例如开启了Web模式的Google Cloud Storage与Amazon S3。 repository的主要特征时存在一个 index.yaml 文件，它包含着repository中存在的Package列表以及用于检索和验证Package的元数据。 在客户端，repositories是通过 helm repo 命令进行管理的。 然而，Helm本身并没有提供相关的工具用于上传charts到远程的repo中。 主要原因是相关的功能实现其实时需要服务端满足一些相关的功能，而这会对repo的搭建带来一定的障碍。 Chart 初始化包 helm create 命令可以接收一个可选参数 --starter 用于指定一个初始化Chart。 它其实就一个普通的Chart，但是存放于 $XDG_DATA_HOME/helm/starters。 对于一个Charts开发者而言，你可以以它为基础来开发你自己的Charts。 在开发Charts时，需要注意如下点： Chart.yaml 文件会被生成器自动重写。 Chart用户可能会去修改Charts的一些内容，因此，需要有相关的注释能够帮助用户快速理解该Chart。 所有 的部分最后都会被指定的Chart名称替换。 目前，唯一添加初始化包的方式就是手动的把Chart包拷贝到 $XDG_DATA_HOME/helm/starters 。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/charts_hooks.html":{"url":"chap03/charts_hooks.html","title":"Charts hooks详解","keywords":"","body":"Chart Hooks详解 Helm提供了一个 Hook 的机制可以使得Charts开发者能够在release生命周期的合适时机进行干预。 例如，你可以使用hooks进行： 在其他Charts安装之前首先创建ConfigMap和Secret。 在安装一个新的Chart之前，首先执行一个Job用于备份数据库，然后在升级完成后执行第二个Job用户恢复数据。 在删除release对象之前，运行一个Job用于使得服务能够优雅退出。 Hooks工作方式与一般的模板类似，但是它们可以使用一些特殊的标注从而可以让Helm对它们进行特殊处理。 在本节中，我们将会讲解Hook模式的一些基本使用方式： 可用的Hooks Helm内置定义了如下的Hooks: 注释名称 功能说明 pre-install 执行时机: 模板渲染完成，但是在向K8s提交之前 post-install 执行时机: 所有资源对象都已经提交给K8s之后 pre-delete 执行时机: 对于delete请求，在请求发送给K8s之前 post-delete 执行时机: 对于delete请求，在请求发送给K8s之后 pre-upgrade 执行时机: 对于升级请求，模板渲染完成，但是在向K8s提交之前 post-upgrade 执行时机: 对于升级请求，模板渲染完成，并提交K8s之后 pre-rollback 执行时机: 对于回滚请求，模板渲染完成，但是在向K8s提交之前 post-rollback 执行时机: 对于回滚请求，模板渲染完成，并提交K8s之后 test 执行时机: 当执行helm test子命令时被调用 (view test docs) Ps: 在helm3中，crd-install hook已经被移除。 Hooks 与 the Release 的生命周期 Hooks可以帮助Chart开发者在release声明周期中定义一些策略，从而可以直接一些相关的操作。 以 helm install 的声明周期为例： 用户运行 helm install foo 命令 Helm库中install API被调用 在完成基本的参数验证后，渲染 foo 的模板 将相关的资源对象信息发送给kubernetes lib库返回release对象或其他数据给客户端 客户端退出 Helm定义了两个hooks在 install 操作的生命周期中，分别是: pre-install 和 post-install。 如果开发者同时实现了 foo chart的这两个hooks，那么整体生命周期的变为了如下方式： 用户运行 helm install foo 命令 Helm库中install API被调用 crds/ 目录下的相关CRDs被安装到K8s中 在完成基本的参数验证后，渲染 foo 的模板 lib库准备执行 pre-install hooks（加载hooks资源到k8s中） lib库对hooks按照权重（默认权重为0）、资源类型、名称进行升序排序 根据排序逆序执行相关的hooks 等待Hook的状态变为Ready（CRDs除外） 提交渲染后的资源对象给K8s。Ps，如果设置了 --wait 参数，则Lib库将会等待所有的资源对象状态变为Ready再进行下一步。 执行post-install hook （加载hooks资源到k8s中） Lib库等待 hook 状态变为Ready。 lib库返回release对象或其他数据给客户端。 客户端退出。 等待Hook执行完成的含义是什么呢？它取决于Hook中定义的资源对象的类型: 如果资源类型是Job 或者 Pod，那么Helm将会等待这个任务成功运行完成。 如果Hook运行失败，那么这个Release对象也会创建失败。 这是一个阻塞性操作，在Job运行过程中，helm客户端会进行阻塞性等待。 对于其他所有类型的资源而言，只要K8s成功加载了对应的资源，Helm就认为该资源的状态已经是 \"Ready\" 了。 当Hook中定义了很多资源对象时，这些资源对象互相之间是串行执行的。 如果对它们定义了不同的权重，那么它们将会按照权重大小依次执行。 从Helm 3.2.0版本开始，拥有相同权重的hook资源与普通资源执行的顺序是一致的，只有拥有不同权重的hook资源才能保证执行顺序。 所以，如果想要定义执行顺序，那么最好的方法就是主动设置相关的权重，如果不设置权重的话，默认为0，可以认为对顺序无关。 Hook资源不受release对象控制 Hook场景的资源目前并没有作为release对象的一部分进行跟踪。 一旦Helm验证这个Hook达到了Ready状态后，它将会让Hook资源自行进行运行。 在Helm3的未来的版本中，一旦release被删除后，对应的hook资源将会被进行垃圾回收。 因此，如果有哪些Hook资源你是希望进行永久保留的，那么就需要增加如下注释：helm.sh/resource-policy: keep。 实际上，这也就意味着如果你在hook中创建了一些资源，你无法通过 helm uninstall 来删除这些资源。 为了删除这些资源，一方面你可以在Hook模板文件中添加 helm.sh/hook-delete-policy 注释， 另一方面也可以 设置资源的生效时间. 编写一个Hook Hooks本质上就是一些带有特殊注释的K8s yaml文件。由于它们也属于template文件，因此它们也可以使用Template中一些基本功能，例如 .Values, .Release 以及 .Template。 例如，对于 templates/post-install-job.yaml 这个template文件而言，定义了一个Job在 post-install 时运行。 apiVersion: batch/v1 kind: Job metadata: name: \"{{ .Release.Name }}\" labels: app.kubernetes.io/managed-by: {{ .Release.Service | quote }} app.kubernetes.io/instance: {{ .Release.Name | quote }} app.kubernetes.io/version: {{ .Chart.AppVersion }} helm.sh/chart: \"{{ .Chart.Name }}-{{ .Chart.Version }}\" annotations: # This is what defines this resource as a hook. Without this line, the # job is considered part of the release. \"helm.sh/hook\": post-install \"helm.sh/hook-weight\": \"-5\" \"helm.sh/hook-delete-policy\": hook-succeeded spec: template: metadata: name: \"{{ .Release.Name }}\" labels: app.kubernetes.io/managed-by: {{ .Release.Service | quote }} app.kubernetes.io/instance: {{ .Release.Name | quote }} helm.sh/chart: \"{{ .Chart.Name }}-{{ .Chart.Version }}\" spec: restartPolicy: Never containers: - name: post-install-job image: \"alpine:3.3\" command: [\"/bin/sleep\", \"{{ default \"10\" .Values.sleepyTime }}\"] 决定该template能够作为hooks的关键点是如下annotation: annotations: \"helm.sh/hook\": post-install 同一个资源可以同时作为多个hooks: annotations: \"helm.sh/hook\": post-install,post-upgrade 类似的事，对于某一个Hook场景，可以存在多个不同的资源对象。 例如，我们可以定义一个secret和一个ConfigMap都是 pre-install 的Hook。 当子Chart中定义了Hooks时，这些Hooks也都会被计算和执行。 目前还不支持在父Chart中禁用子Charts中定义的Hooks。 我们可以定义 Hooks 的权重，从而能够保证多个Hooks时按照指定的顺序执行。 权重的定义方式如下： annotations: \"helm.sh/hook-weight\": \"5\" Hook的权重可以是正数、也可以是负数，需要以字符串的形式表示。 Helm在执行特定场景的Hooks时，会对这些Hooks的权重进行排序，并从大到小依次执行。 Hook 删除策略 我们可以定义 Hook资源的删除策略。 Hook资源删除策略的annotation的关键词如下： annotations: \"helm.sh/hook-delete-policy\": before-hook-creation,hook-succeeded 你可以选择一个或多个定义好的annotation值： Annotation Value Description before-hook-creation 在新Hook运行时，删除之前的Hook资源 (default) hook-succeeded 当Hook资源Ready后，删除对应的Hook资源 hook-failed 当Hook资源执行失败后，删除对应的Hook资源 如果没有显式指定Hook的删除策略，那么默认策略为 before-hook-creation。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/chart_tests.html":{"url":"chap03/chart_tests.html","title":"Charts测试篇","keywords":"","body":"测试你的Charts 在一个Chart中，往往会包含一批K8s资源对象。 作为Chart的开发人员，我们可能通常需要编写一些测试Case验证我们的Chart在安装过程中是否可以正常工作。 同时，这些测试Case也可以帮助Chart的用户更好的理解如何使用这些Chart。 在Helm Chart中，测试Case是保存在 templates/ 目录下，它们是一些Job对象并指定了要运行的命令和容器。 当测试运行成功时，容器的退出码预期应该为0。 这些Job对象必须包含Helm Test相关的注释，即：helm.sh/hook: test。 Ps：在Helm3之前，Job中需要包含Helm测试的Hook注释为 helm.sh/hook: test-success 或 helm.sh/hook: test-failure。 为了保证兼容，helm.sh/hook: test-success 在Helm3中保存了下来，等价于 helm.sh/hook: test。 测试示例: 验证你的values.yaml文件中配置是否可以正常进行替换。 确保你的用户名和密码是正确的 确保错误的用户名和密码不能正常工作 验证你的Service可以正常创建并且能够正常进行负载均衡。 等等。 你可以使用 helm test 来针对一个release对应运行相关预定义的测试。 对于一个Chart用户而言，这是一个很好的方案来验证他们创建的release对象是否能够正常工作。 示例 下面是一个针对 bitnami wordpress chart 应用定义的Helm Test Pod。 如果你下载下来该Chart，你可以看到如下文件： $ helm repo add bitnami https://charts.bitnami.com/bitnami $ helm pull bitnami/wordpress --untar wordpress/ Chart.yaml README.md values.yaml charts/ templates/ templates/tests/test-mariadb-connection.yaml wordpress/templates/tests/test-mariadb-connection.yaml 文件内容如下： {{- if .Values.mariadb.enabled }} apiVersion: v1 kind: Pod metadata: name: \"{{ .Release.Name }}-credentials-test\" annotations: \"helm.sh/hook\": test spec: containers: - name: {{ .Release.Name }}-credentials-test image: {{ template \"wordpress.image\" . }} imagePullPolicy: {{ .Values.image.pullPolicy | quote }} {{- if .Values.securityContext.enabled }} securityContext: runAsUser: {{ .Values.securityContext.runAsUser }} {{- end }} env: - name: MARIADB_HOST value: {{ template \"mariadb.fullname\" . }} - name: MARIADB_PORT value: \"3306\" - name: WORDPRESS_DATABASE_NAME value: {{ default \"\" .Values.mariadb.db.name | quote }} - name: WORDPRESS_DATABASE_USER value: {{ default \"\" .Values.mariadb.db.user | quote }} - name: WORDPRESS_DATABASE_PASSWORD valueFrom: secretKeyRef: name: {{ template \"mariadb.fullname\" . }} key: mariadb-password command: - /bin/bash - -ec - | mysql --host=$MARIADB_HOST --port=$MARIADB_PORT --user=$WORDPRESS_DATABASE_USER --password=$WORDPRESS_DATABASE_PASSWORD restartPolicy: Never {{- end }} 针对一个Release对象运行测试用例的步骤 首先，你需要在你的K8s集群中创建一个对应的release对象。 然后，你需要等待所有的Pod都可以正常运行。 Ps：如果你install命令完成后立马运行测试，此时可能会得到一些错误信息，需要等待所有Pod部署完成后再重新进行测试。 $ helm install quirky-walrus wordpress --namespace default $ helm test quirky-walrus Pod quirky-walrus-credentials-test pending Pod quirky-walrus-credentials-test pending Pod quirky-walrus-credentials-test pending Pod quirky-walrus-credentials-test succeeded Pod quirky-walrus-mariadb-test-dqas5 pending Pod quirky-walrus-mariadb-test-dqas5 pending Pod quirky-walrus-mariadb-test-dqas5 pending Pod quirky-walrus-mariadb-test-dqas5 pending Pod quirky-walrus-mariadb-test-dqas5 succeeded NAME: quirky-walrus LAST DEPLOYED: Mon Jun 22 17:24:31 2020 NAMESPACE: default STATUS: deployed REVISION: 1 TEST SUITE: quirky-walrus-mariadb-test-dqas5 Last Started: Mon Jun 22 17:27:19 2020 Last Completed: Mon Jun 22 17:27:21 2020 Phase: Succeeded TEST SUITE: quirky-walrus-credentials-test Last Started: Mon Jun 22 17:27:17 2020 Last Completed: Mon Jun 22 17:27:19 2020 Phase: Succeeded [...] 说明 在 templates/ 目录下，你可以定义若干个yaml文件来包含你想要的全部的测试用例。 你也可以在 templates/ 目录下创建一个子目录 tests/ 目录来存放你的相关测试用例，例如： /templates/tests/。 每次测试Case其实都是一个Helm hook，所以你可以添加一些 helm.sh/hook-weight 或 helm.sh/hook-delete-policy 之类的注释。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/library_charts.html":{"url":"chap03/library_charts.html","title":"Library Charts","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/provenance.html":{"url":"chap03/provenance.html","title":"Chart起源验证","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/chart_repository.html":{"url":"chap03/chart_repository.html","title":"ChartRepo指南","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/registries.html":{"url":"chap03/registries.html","title":"注册中心","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/architecture.html":{"url":"chap03/architecture.html","title":"Helm架构","keywords":"","body":"Helm架构 本文主要会介绍 Helm 整体的体系结构。 Helm 的定位和目标 Helm 主要用于管理名为 chart 的 Kubernetes 包的工具。 Helm可以做以下的事情： 从头开始创建新的chart。 将chart打包成归档(tgz)文件。 与存储chart的仓库进行交互。 在现有的Kubernetes集群中安装和卸载chart。 管理与Helm一起安装的chart的发布周期。 对于Helm，有三个重要的概念： chart 创建Kubernetes应用程序所必需的一组信息。 config 包含了可以合并到打包的chart中的配置信息，用于创建一个可发布的对象。 release 是一个与特定配置相结合的chart的运行实例。 Helm 组件 Helm是一个可执行文件，执行时分成两个不同的部分： Helm 客户端 Helm客户端 是终端用户的命令行客户端。负责以下内容： 本地chart开发。 仓库管理。 管理发布。 与 Helm 库建立接口 发送安装的 chart 发送升级或卸载现有发布的请求 Helm 库 Helm 库提供执行所有 Helm 操作的逻辑，与Kubernetes API服务交互并提供以下功能： 结合chart和配置来构建版本。 将chart安装到Kubernetes中，并提供后续发布对象。 与Kubernetes交互升级和卸载chart。 独立的 Helm 库封装了 Helm 逻辑以便不同的客户端可以使用它。 实现方式 Helm 的客户端和 lib 库都是使用 Go 来开发的。 Helm lib 库是使用 K8s 提供的客户端 Lib 库与 K8s 进行通信，通信的方式是 REST + JSON 格式。 Helm 的元数据存储在 K8s 的密钥中，自己本身不需要任何数据库。 Helm 的配置文件通常是以 YAML 格式编写的。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/advanced.html":{"url":"chap03/advanced.html","title":"Helm高级功能","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/kubernetes_distros.html":{"url":"chap03/kubernetes_distros.html","title":"Helm与K8s发布版本说明","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/rbac.html":{"url":"chap03/rbac.html","title":"rbac权限控制","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/plugins.html":{"url":"chap03/plugins.html","title":"Helm插件","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/v2_v3_migration.html":{"url":"chap03/v2_v3_migration.html","title":"Helm2迁移到Helm3","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/getting_started.html":{"url":"chap05/getting_started.html","title":"Chart 模板开发引言","keywords":"","body":"Chart 模板开发引言 Chart 模板开发章节中，我们会讲解如何来制作 Chart。 首先，我们需要了解如何创建一个 Chart 并添加一个模板。 Charts 如之前 Charts详解 中介绍，Helm chart的结构如下： mychart/ Chart.yaml values.yaml charts/ templates/ ... templates/ 目录包括了模板文件。 当 helm 应用一个 charts 时，会通过模板渲染引擎将所有文件发送到 templates/ 目录中。 然后收集模板的结果并发送给Kubernetes。 values.yaml 文件也会被导入到模板中。 这个文件包含了chart的默认值。 这些值会在用户执行helm install或helm upgrade时被覆盖。 Chart.yaml 文件包含了该chart的描述。 charts/目录可以包含其他的chart(称之为子chart)。 制作第一个 Charts 下面，我们会创建一个名为mychart的chart，然后会在chart中创建一些模板。 首先通过 helm 命令来创建一个 chart 。 helm create mychart # Creating mychart 如果你看看 mychart/templates/ 目录，会注意到一些文件已经存在了： NOTES.txt: chart的\"帮助文本\"。这会在你的用户执行helm install时展示给他们。 deployment.yaml: 创建Kubernetes 工作负载的基本清单 service.yaml: 为你的工作负载创建一个 service终端基本清单。 _helpers.tpl: 放置可以通过chart复用的模板辅助对象。 然后我们要做的是把它们全部删掉！ 这样我们就可以从头开始学习我们的教程。 rm -rf mychart/templates/* Ps: 编写生产环境级别的chart时，有这些chart的基础版本会很有用。因此在日常编写中，我们通常不会删除它们。 第一个模板 第一个创建的模板是ConfigMap。 Kubernetes中，配置映射只是用于存储配置数据的对象。其他组件，比如pod，可以访问配置映射中的数据。 因为配置映射是基础资源，对我们来说是很好的起点。 让我们以创建一个名为 mychart/templates/configmap.yaml的文件开始： apiVersion: v1 kind: ConfigMap metadata: name: mychart-configmap data: myvalue: \"Hello World\" Ps: 模板名称不需要遵循严格的命名模式。但是建议以.yaml作为YAML文件的后缀，以.tpl作为helper文件的后缀。 上述YAML文件是一个简单的配置映射，构成了最小的必需字段。因为文件在 mychart/templates/ 目录中，它会通过模板引擎传递。 像这样将一个普通YAML文件放在mychart/templates/目录中是没问题的。 当Helm读取这个模板时会按照原样传递给Kubernetes。 有了这个简单的模板，现在有一个可安装的chart了。现在安装如下： helm install full-coral ./mychart # NAME: full-coral # LAST DEPLOYED: Tue Jul 20 09:04:09 2021 # NAMESPACE: default # STATUS: deployed # REVISION: 1 # TEST SUITE: None 接下来，我们可以使用helm来查询版本信息并查看实际渲染后的模板。 helm get manifest full-coral # --- # # Source: mychart/templates/configmap.yaml # apiVersion: v1 # kind: ConfigMap # metadata: # name: mychart-configmap # data: # myvalue: \"Hello World\" 其中，helm get manifest 命令后跟一个发布名称(full-coral)然后打印出了所有已经上传到server的Kubernetes资源。 每个文件以---开头表示YAML文件的开头，然后是自动生成的注释行，表示哪个模板文件生成了这个YAML文档。 从这个地方开始，我们看到的YAML数据确实是configmap.yaml文件中的内容。 现在卸载发布： helm uninstall full-coral。 添加一个简单的模板调用 将name硬编码到一个资源中不是很好的方式。 在一个namespace下，资源名称应该是唯一的。 因此，我们可能希望通过插入发布名称来生成name字段。 Ps: 由于DNS系统的限制，name字段长度限制为63个字符。因此发布名称限制为53个字符。 Kubernetes 1.3及更早版本限制为24个字符 (名称长度是14个字符)。 对应改变一下configmap.yaml： apiVersion: v1 kind: ConfigMap metadata: name: {{ .Release.Name }}-configmap data: myvalue: \"Hello World\" 其中，我们唯一的修改就是 name 字段的取值，我们引入了模板命令 {{ .Release.Name }}。 模板命令 {{ .Release.Name }} 将发布名称注入了模板。 值作为一个命名空间对象传给了模板，用点(.)分隔每个命名空间的元素。 其中： Release前面的点表示从作用域最顶层的命名空间开始（稍后会谈作用域）。 这样.Release.Name就可解读为“通顶层命名空间开始查找 Release对象，然后在其中找Name对象”。 Release是一个Helm的内置对象，关于 Release ，后面会进行更加详细的说明，现在只需要知道它可以显式获取发布对象的名称即可。 现在再次安装资源，并查询对应的完整 yaml 配置，可以看到的是： configmap的名称从之前的mychart-configmap 变为了 full-coral-configmap。 由此我们已经看到了最基本的模板替换功能：YAML文件有嵌入在之间的模板命令进行替换。 下一部分，会深入了解模板， 但在这之前，有个快捷的技巧可以加快模板的构建过程中的调试速度。 当你想测试模板渲染但又不想安装任何内容时， 可以使用 helm install --debug --dry-run goodly-guppy ./mychart 命令。 在执行helm install的时候带上这两个参数就可以把对应的 values 值和生成的最终的资源清单文件打印出来，而不会真正的去部署一个release实例。 Ps：这种方式虽然会使得调试过程相对简单，但是不能完全保证一定可以在 K8s 中正常工作，因此，调试完成后，还是需要真正 install 进行测试。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/builtin_objects.html":{"url":"chap05/builtin_objects.html","title":"Chart 中的内置变量","keywords":"","body":"Chart 中的内置变量 在 helm 中，变量会从模板引擎传递到模板中， 我们也可以编写代码来传递变量甚至创建新的变量。 一个变量可以仅仅是一个简单的值，也可以是一个嵌套的对象。 例如，对于 Release 变量而言，它还包含了 Name 属性等。 在上一节中，我们用 {{ .Release.Name }} 在模板中插入版本名称。 Release是你可以在模板中访问的高级对象之一。 Release 变量 下面，我们就来具体看一下 helm 中 Release 变量具体包含了哪些属性吧。 Release： 该变量描述了版本发布本身。包含了以下属性： Release.Name： release名称 Release.Namespace： 版本中包含的命名空间(如果manifest没有覆盖的话) Release.IsUpgrade： 如果当前操作是升级或回滚的话，该值为true Release.IsInstall： 如果当前操作是安装的话，该值为true Release.Revision： 此次修订的版本号。安装时是1，每次升级或回滚都会自增 Release.Service： 该service用来渲染当前模板。一般是Helm。 Values 变量 Values是从values.yaml文件和用户提供的文件传进模板的。Values默认为空。 Chart 变量 Chart.yaml文件内容。 Chart.yaml里的任意数据在这里都可以可访问的。比如 {{ .Chart.Name }}-{{ .Chart.Version }} 会打印出 mychart-0.1.0。 Files 变量 在chart中允许访问所有的非特殊文件。 当你不能使用它访问模板时，你可以访问其他文件。 Files.Get 通过文件名获取文件的方法。 （.Files.Getconfig.ini） Files.GetBytes 用字节数组代替字符串获取文件内容的方法。 对图片之类的文件很有用。 Files.Glob 用给定的shell glob模式匹配文件名返回文件列表的方法。 Files.Lines 逐行读取文件内容的方法。迭代文件中每一行时很有用。 Files.AsSecrets 使用Base 64编码字符串返回文件体的方法。 Files.AsConfig 使用YAML格式返回文件体的方法。 Capabilities Capabilities 提供关于Kubernetes集群支持功能的信息。 Capabilities.APIVersions 是一个版本集合。 Capabilities.APIVersions.Has $version 说明集群中的版本 (e.g., batch/v1) 或是资源 (e.g., apps/v1/Deployment) 是否可用。 Capabilities.KubeVersion 和 Capabilities.KubeVersion.Version 是Kubernetes的版本号。 Capabilities.KubeVersion.Major Kubernetes的主版本。 Capabilities.APIVersions.KubeVersion.Minor Kubernetes的次版本。 Template Template 包含了已经被执行的当前模板信息。 Template.Name: 当前模板的命名空间文件路径 (e.g. mychart/templates/mytemplate.yaml)。 Template.BasePath: 当前chart模板目录的路径 (e.g. mychart/templates) Summary helm 中所有内置的变量都是以大写字母开始，这符合 Go 语言的命令惯例。 当你创建自己的变量时，可以按照团队约定自由设置。例如，可以将自定义变量全部设置为小写字母开头，从而可以和内置变量进行区分。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-20 01:53:58 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "}}